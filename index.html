<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">
    <title>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ </title>
</head>
<body>
    <header>
        <p>Блог компании Яндекс.</p>
    </header>
    <main>
        <article> <!-- Комментарий -->
            <p>Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,какой он
                красивый, ни то,
                какой он удобный. Никому не понравится, когда все
        тормозит. Мы регулярно добавляем в <em>Яндекс</em>.Почту новую функциональность,
        иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код
        и новая логика. Всё это напрямую влияет на скорость работы интерфейса.</p>
        </article>
        <p>Этапы первой загрузки:</p>
        <ol reversed>
            <li>* подготовка;</li>
            <li>* загрузка статики (HTTP-запрос и парсинг);</li>
            <li>* исполнение модулей;</li>
            <li>* инициализация базовых объектов;</li>
            <li>* отрисовка.</li>
        </ol>
        <p>Этапы отрисовки любой страницы:</p>
        <ul>
            <li>подготовка к запросу на сервер;</li>
            <li>запрос данных с сервера;</li>
            <li>шаблонизация;</li>
            <li>обновление DOM.</li>
        </ul>
        <p>
            — <q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - говорим мы
            — <q>Что же дальше?</q> - вопрошаете вы
            — <q>А давай построим график!</q> - отвечаем мы
            — <q>А что будем считать?</q> - уточняете вы
        </p>
        <p>Как вы знаете, медиана – это серединное, а не среднее значение в выборке.<br>
            Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.
            В общем случае медиана отлично показывает, сколько грузится средний пользователь.
        </p>
        <p>
            В случае ускорения или замедления медиана, конечно, изменится. Но она не может
            рассказать, сколько пользователей ускорилось, а сколько замедлилось.<br>

            <abbr>APDEX</abbr>abbr> – метрика, которая сразу говорит: хорошо или плохо. Метрика
            работает очень просто.
        </p>
        <p>Мы выбираем временной интервал [0; t], такой, что если
            время показа страницы попало в него, то пользователь счастлив. Берем еще один
            интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
            показана за это время, то пользователь в целом удовлетворен скоростью работы,
            но уже не настолько счастлив. И применяем <strong>формулу</strong>:

            (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
            Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
            хорошо или плохо работает почта.
        </p>
        <p>Как мы измеряем

        Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
        причину замедления: медленнее стал отвечать сервер либо слишком долго
            выполняется JavaScript. Выглядит это примерно так:
        </p>
        <code>
            this.timings['look-ma-im-start'] = Date.now();
            this.timings['look-ma-finish'] = Date.now();
        </code>
        <p>C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при
            отправке рассчитываются. На этапах разница между “end” и “start” не считается,
            а все вычисления производятся в конце:
        </p>
        <code>
            var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];
        </code>
        <p>И на сервер прилетают подобные записи:</p>
        <samp>serverResponse=50&domUpdate=60</samp>

        <h4>Как мы <mark>ускоряем</mark></h4>

        <p>Чтобы снизить время загрузки почты при выходе новых версий,
            мы уже делаем следующее:
        </p>
        <ul>
            <li>включаем gzip;</li>
            <li>выставляем заголовки кэширования;</li>
            <li>фризим CSS, JS, шаблоны и картинки;</li>
            <li>используем CDN;</li>
        </ul>
            <p>
                Мы подумали: «А что если хранить где-то старую версию файлов, а при выходе новой
                передавать только diff между ней и той, которая сохранена у пользователя?»
                В браузере же останется просто наложить патч на клиенте.
            </p>
            <p>
                На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,
                RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они
                не получили должного распространения в браузерах и на серверах.
            </p>
        </div>

        <p>Мы же решили сделать свой <ruby>аналог<rt>на JS</rt></ruby> . Чтобы реализовать этот
            метод обновления,
            начали искать реализации diff на JS. На популярных хостингах кода нашли
            библиотеки:
            - VCDiff
            - google-diff-patch-match
        </p>
        <table>
            <caption>Для окончательного выбора библиотеки нам нужно сравнить:</caption>
            <tr>
                <td>Библиотека</td><!--обозначает ячейку таблицы-->
                <td>IE 9</td>
                <td>Opera 12</td>
            </tr>
            <tr>
                <td>vcdiff  </td>
                <td> 8</td>
                <td> 5</td>
            </tr>
            <tr>
                <td>google diff</td>
                <td>1363</td>
                <td>76</td>
            </tr>
        </table>
        <p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,
            где и как хранить статику на клиенте.</p>
        <figure>
            <figcaption>Формат файла с патчами для проекта выглядит так:.</figcaption>
            <pre>
                <code>[
                    {
                    "k": "jane.css",
                    "p": [patch],
                    "s": 4554
                    },
                    {
                    "k": "jane.css",
                    "p": [patch],
                    "s": 4554
                    }
                ]</code>
            </pre>
        </figure>


        <p>
            То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
            каждого объекта есть три свойства. k — названия ключа в localStorage для этого
            ресурса. p — патч для ресурса, который сгенерировал vcdiff. s — чексумма для
            ресурса актуальной версии, чтобы потом можно было проверить правильность
            наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.

            Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)
            — итерационный метод численной оптимизации, предназначенный для
            нахождения локального максимума/минимума нелинейного функционала
            без ограничений.
        </p>
        <p>
            дано <var>&epsilon;</var>, <var>x<sub>0</sub></var><br>
            инициализировать<var>H<sub>0</sub></var><br>
            <var>k</var> =0<br>
            <strong>while</strong>||∇<var>f<sub>k</sub></var>||><var>&epsilon</var><br>
            найти направление p<sub>k</sub> = -C<sub>k</sub>∇f<sub>k</sub><br>
            вычислить x<sub>k+1</sub>=x<sub>k</sub>+α<sub>k</sub>p<sub>k</sub>, α<sub>k</sub> удовлетворяет условиям Вольфе<br>
            обозначить s<sub>k</sub>=x<sub>k+1</sub>-x<sub>k</sub> и y<sub>k</sub>=∇f<sub>k+1</sub>-∇f<sub>k</sub><br>
            вычислить <var>C<sub>k+1</sub></var>
            k = k + 1<br>
            <strong>end</strong>
        </p>
        <p>
            Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:
            CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный для проверки
            целостности данных
            md5 - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»
            или дайджестов сообщения произвольной длины и последующей проверки
            их подлинности.

            Потому что он быстрый, компактный и легок в реализации.

            Итог

            Фактически мы экономим 80-90% трафика.
        </p>
        <table>
            <caption>Размер загружаемой статитки в байтах:</caption>
            <thead> <!--обозначает шапку таблицы-->
            <tr> <!--обозначает строку данных-->
                <th>Релиз</th> <!--обозначает ячейку шапки-->
                <th>С патчем</th>
                <th>Без патча</th>
            </tr>
            </thead>
            <tfoot> <!--обозначает подвал таблицы-->
                <tr>
                    <td>7.7.22</td>
                    <td>483</td>
                    <td>3 995</td>
                </tr>
            </tfoot>
            <tbody> <!--обозначает данные таблицы-->
                <tr>
                    <td>7.7.20</td><!--обозначает ячейку таблицы-->
                    <td>397</td>
                    <td>174 549</td>
                </tr>
            <tr>
                <td>7.7.21</td><!--обозначает ячейку таблицы-->
                <td>383</td>
                <td>53 995</td>
            </tr>
            </tbody>
        </table>
        <p>Автор: @doochik
            С++ разработик
            Электронная почта: (doochik@yandex-team.ru)
        Компания: Яндекс</p>
        <p>Комментарии (3):</p>
        <article>
            <header>
                <p>Mogaika (mogaika@yandex-team.ru)30 ноября 2014 в 17:05</time></p>
            </header>
            А можете привести сравнение, на сколько быстрее грузится lite версия?
        </article>
        <article>
            <header>
                <p>JIguse (mrawesome@yandex.ru) <time datetime="2014-11-29T21:30Z">29 ноября 2014 в 21:30</time></p>
            </header>
            Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
            подробностями о внутренней работе сервисов.
        </article>
        <article>
            <header>
                <p>Brister (brist89@yandex-team.ru)<time datetime="2014-11-22T17:35Z">22 ноября 2014 в 17:35</time></p>
            </header>
            кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
            Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
            хорошо или плохо работает почта.

            наверное все-таки от 0.5 до 1
        </article>
        <small>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:</small>
            <p>help.yandex.ru/metrika/reports/monitoring_timing.xml</p>
</main>
    <footer>© Яндекс, <a href="mailto:help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10</footer>
</body>
</html>
